#!/usr/bin/env python3
""" covid19-vi  -  Visualization utilities for the COVID-19 data from Johns Hopkins.

    Copyright (C) 2020  Natalya Langford

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
__author__ = 'Natalya Langford'
__copyright__ = 'Copyright (C) 2020 Natalya Langford'
__credits__ = ['Ricks-Lab - Collaborator']
__license__ = 'GNU General Public License'
__program_name__ = 'covid19-vi'
__version__ = 'v0.0.1'
__maintainer__ = 'Natalya Langford'
__status__ = 'Under Development'
__docformat__ = 'reStructuredText'
# pylint: disable=multiple-statements
# pylint: disable=line-too-long

import argparse
import sys
import os
from datetime import datetime
import io
import pickle
import requests
import us_state_abbrev as ussa
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


class CovidData:
    _covid_data = {'global': {'confirmed': 'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv',
                              'deaths': 'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv'},
                   'usa': {'confirmed': 'https://static.usafacts.org/public/data/covid-19/covid_confirmed_usafacts.csv',
                           'deaths': 'https://static.usafacts.org/public/data/covid-19/covid_deaths_usafacts.csv'}}
    _pickle_filename = 'covid_data.pickle'
    _prov_state_countries = ['China', 'Canada', 'Australia', 'France', 'United Kingdom', 'Netherlands', 'Denmark']
    _data_source = {'global': {'link': 'https://github.com/CSSEGISandData/COVID-19',
                               'name': 'Johns Hopkins University'},
                    'usa': {'link': 'https://usafacts.org/issues/coronavirus/',
                            'name': 'USA Facts'}}
    _analytics_source = 'https://github.com/natalyalangford/COVID19_plots'
    _valid_args = {'type': ['deaths', 'confirmed'],
                   'region': ['country', 'state', 'province', 'county', 'county-state']}

    def __init__(self, args, download=False):
        """
        Initialize a CovidData object and populate from interweb if download is True.
        :param download:
        :type download: Bool
        :return None
        """
        self.data = {'global': {'data_date': None,
                                'download_date': None,
                                'confirmed': None,
                                'deaths': None,
                                'recoveries': None},
                     'usa': {'data_date': None,
                             'download_date': None,
                             'confirmed': None,
                             'deaths': None,
                             'recoveries': None}}
        self.args = args
        if not self.chk_args():
            print('Error: invalid arguments.')
            sys.exit(-10)
        if not self.read_datafile(download=download):
            print('Error: error while downloading sources.')
            sys.exit(-20)

    def chk_args(self):
        if self.args.type not in self._valid_args['type']:
            print('Error in value for --type {}, valid values are {}'.format(self.args.type,
                                                                             self._valid_args['type']))
            return False
        if self.args.region not in self._valid_args['region']:
            print('Error in value for --region {}, valid values are {}'.format(self.args.region,
                                                                               self._valid_args['region']))
            return False
        if self.args.state not in ussa.us_state_abbrev.values():
            print('Error in value for --state {}, {} is not a valid US state abbreviation')
            return False
        return True

    def print_sources(self):
        """
        :return: None
        """
        for k, v in self._covid_data.items():
            print(k)
            [print(' {}: {}'.format(k2, v2)) for k2, v2 in v.items()]

    def read_datafile(self, download=False):
        """
        Read covid-19 data from the repository datafiles or a pickle file depends on value of download.
        Source: https://github.com/Ricks-Lab/amdgpu-utils/blob/c10dba61f11b9e5fb44d24acd1fa74122668afc2/GPUmodules/PCImodule.py

        :param download: Download from the interweb if True, else read pickled data.
        :type download: bool
        :return: bool
        """
        if not download and os.path.isfile(self._pickle_filename):
            # Read pickle file.
            with open(self._pickle_filename, 'rb') as f:
                self.data = pickle.load(f)
            return True

        for zone, zone_dict in self._covid_data.items():
            #if zone == 'global': continue
            for report_type, link in zone_dict.items():
                print('Downloading: Zone: {}, Type: {}'.format(zone, report_type))
                if self.args.debug:
                    temp_file_name = 'covid_{}_{}_{}.csv'.format(zone, report_type, 'test')
                else:
                    temp_file_name = 'covid_{}_{}_{}.csv'.format(zone, report_type,
                                                                 datetime.utcnow().strftime('%m%d_%H%M%S'))
                if not self.args.debug or not os.path.isfile(temp_file_name):
                    try:
                        csv_data = requests.get(link).content
                    except requests.exceptions.RequestException as err:
                        print('Error [{}]: could not download:\n   [{}].'.format(err, link))
                        continue
                read_df = pd.read_csv(io.StringIO(csv_data.decode('utf-8', errors='replace')), sep=',')
                # Delete unnamed columns
                read_df = read_df.loc[:, ~read_df.columns.str.contains('^Unnamed')]
                if zone == 'usa':
                    # Delete rows with null state or county name
                    read_df = read_df.loc[(~read_df['County Name'].isnull() | ~read_df['State'].isnull())].copy()
                with pd.option_context('display.max_rows', None, 'show_dimensions', False):
                    print(read_df.head(1))
                self.data[zone][report_type] = self.read_csv_file(csv_data, zone, read_df)
                self.data[zone]['data_date'] = self.data[zone][report_type].columns[-5]
            self.data[zone]['download_date'] = datetime.utcnow()

        # Save pickle file.
        with open(self._pickle_filename, 'wb') as f:
            pickle.dump(self.data, f)

        return True

    @staticmethod
    def aggregate_world(df):
        """
        :param df: dataframe
        :return: list
        """
        ac_df = df.loc[df['Province/State'].isnull()].copy()
        ac_df.iloc[:, 5:] = ac_df.iloc[:, 5:].fillna(0)
        world_df = ac_df.head(1).copy()
        world_df.iloc[:, 5:] = ac_df.values[:, 5:].sum(axis=0)
        world_df.loc[:, 'Country/Region'] = 'Global'
        world_df.loc[:, 'Province/State'] = np.NaN
        world_df.loc[:, 'Lat'] = 0.0
        world_df.loc[:, 'Long'] = 0.0
        fdf = pd.concat([df, world_df], ignore_index=True)
        return fdf

    @staticmethod
    def aggregate_state_prov(df, file_country):
        """
        :param df:
        :param file_country:
        :return: list
        """
        if file_country == 'US':
            fdf = df.copy()
            state_list = df['State'].unique()
            # TODO - Need to replace with pivot
            for state in state_list:
                sc_df = df.loc[df['State'] == state, :].copy()
                state_df = sc_df.head(1).copy()
                state_df.loc[0, 4:] = 0
                sc_df.iloc[:, 4:] = sc_df.iloc[:, 4:].fillna(0)
                state_df.loc[:, 4:] = sc_df.values[:, 4:].sum(axis=0)
                state_df = state_df.head(1).copy()
                state_df.loc[:, 'County Name'] = np.NaN
                fdf = pd.concat([fdf, state_df], ignore_index=True)
        else:
            sp_df = df.loc[df['Country/Region'] == file_country, :].copy()
            sp_df.iloc[:, 5:] = sp_df.iloc[:, 5:].fillna(0)
            country_df = sp_df.head(1).copy()
            country_df.loc[:, 5:] = sp_df.values[:, 5:].sum(axis=0)
            country_df.loc[:, 'Province/State'] = np.NaN
            fdf = pd.concat([df, country_df], ignore_index=True)
        return fdf

    def read_csv_file(self, file_name, zone, df=None):
        """
        Read and pre-process the csv data files.  Format is from Johns Hopkins GitHub repo.
        :param file_name: File name of the csv file to be processed.
        :param zone: global or usa file source.
        :param df:
        :return: list
        """
        if df is None:
            try:
                df = pd.read_csv(file_name)
            except UnicodeDecodeError:
                df = pd.read_csv(file_name, encoding='ISO-8859-1')

        # TODO - Need regression fit to calculate rate of increase
        if zone == 'global':
            for ps_country in self._prov_state_countries:
                df.loc[(df['Province/State'].isna()) & (df['Country/Region'] == ps_country),
                           'Province/State'] = ps_country
                df = self.aggregate_state_prov(df, ps_country)
            df = self.aggregate_world(df)
            df.loc[df['Country/Region'] == 'Taiwan*', 'Country/Region'] = 'Taiwan'
        else:
            df = self.aggregate_state_prov(df, 'US')
        df.loc[:, 'Yesterday'] = df.iloc[:, -2]
        df.loc[:, 'Total'] = df.iloc[:, -2]
        df.loc[:, 'DayIncrease'] = df.loc[:, 'Total'] - df.loc[:, 'Yesterday']
        df.loc[:, '%DayIncrease'] = (df.loc[:, 'DayIncrease'] / df.loc[:, 'Yesterday'])
        df.loc[df['%DayIncrease'].isna(), '%DayIncrease'] = 0.0
        df.loc[:, '%DayIncrease'] = round(100.0 * df.loc[:, '%DayIncrease'], 1)
        return df

    def top_ten(self, plot=False):
        """
         Generate tabular data report.
        :param plot:
        :type plot: bool
        :return: None
        """
        plot_file_name_suffix = 'png'
        table_file_name_suffix = 'txt'
        report_file_name = None
        plot_df = pd.DataFrame()
        if self.args.region == 'country':
            report_file_name = '{}_{}_{}'.format(self.args.type, self.args.region, 'global')
            tdf = self.data['global'][self.args.type].copy()
            tdf = tdf.loc[tdf['Province/State'].isnull()]
            tdf = tdf.sort_values(['Total'], ascending=False).head(self.args.length)
            if plot:
                plot_df = tdf.copy()
            tdf = tdf.drop('Province/State', axis=1)
            num_cols = tdf.shape[1]
            col_select = np.r_[0:1, num_cols-11:num_cols]
            ttdf = tdf.iloc[:, col_select].copy()
        elif self.args.region == 'state' or self.args.region == 'province':
            report_file_name = '{}_{}_{}'.format(self.args.type, self.args.region, self.args.country)
            if self.args.country == 'US':
                ldf = self.data['usa'][self.args.type]
                ldf = ldf.loc[ldf['County Name'].isnull()].copy()
                ldf = ldf.sort_values(['Total'], ascending=False).head(self.args.length)
                if plot:
                    plot_df = ldf.copy()
                num_cols = ldf.shape[1]
                col_select = np.r_[2, num_cols-10:num_cols]
                ttdf = ldf.iloc[:, col_select].copy()
            else:
                ldf = self.data['global'][self.args.type]
                ldf = ldf.loc[ldf['Country/Region'] == self.args.country].copy()
                ldf.loc[(ldf['Province/State'].isna()), 'Province/State'] = 'Total'
                ldf = ldf.sort_values(['Total'], ascending=False).head(self.args.length)
                if plot:
                    plot_df = ldf.copy()
                num_cols = ldf.shape[1]
                col_select = np.r_[0:2, num_cols-8:num_cols]
                ttdf = ldf.iloc[:, col_select].copy()
        elif self.args.region == 'county':
            report_file_name = '{}_{}_{}'.format(self.args.type, 'county', self.args.state)
            usdf = self.data['usa'][self.args.type]
            stdf = usdf.loc[usdf['State'] == self.args.state].copy()
            stdf.loc[(stdf['County Name'].isna()), 'County Name'] = 'Total'
            stdf = stdf.sort_values(['Total'], ascending=False).head(self.args.length)
            if plot:
                plot_df = stdf.copy()
            num_cols = stdf.shape[1]
            col_select = np.r_[1:3, num_cols-8:num_cols]
            ttdf = stdf.iloc[:, col_select].copy()
        elif self.args.region == 'county-state':
            report_file_name = '{}_{}_{}'.format(self.args.type, 'county-state', self.args.country)
            csdf = self.data['usa'][self.args.type].copy()
            csdf = csdf.loc[~csdf['County Name'].isnull()].copy()
            csdf = csdf.sort_values(['Total'], ascending=False).head(self.args.length)
            if plot:
                plot_df = csdf.copy()
            num_cols = csdf.shape[1]
            col_select = np.r_[1:3, num_cols - 8:num_cols]
            ttdf = csdf.iloc[:, col_select].copy()
        else:
            print('Error: Invalid report specified.')
            sys.exit(-1)

        # Display and/or write report table.
        if self.args.showtable or self.args.savetable:
            file_ptr_list = [sys.stdout] if self.args.showtable else []
            table_file_name = '{}.{}'.format(report_file_name, table_file_name_suffix)
            if self.args.savedir:
                if not os.path.isdir(self.args.savedir):
                    os.mkdir(self.args.savedir, 0o775)
                table_file_name = os.path.join(self.args.savedir, table_file_name)
            if self.args.savetable: file_ptr_list.append(open(table_file_name, 'w'))
            for fp in file_ptr_list:
                # TODO - display age of data.
                print('Top {} {} Report - {}'.format(self.args.length, self.args.region, self.args.type), file=fp)
                print('  Extract downloaded: {} UTC'.format(self.data['global']['download_date']), file=fp)
                print('  Data last data point date: {}'.format(self.data['global']['data_date']), file=fp)
                with pd.option_context('display.max_rows', None, 'show_dimensions',  False):
                    ttdf.reset_index(drop=True, inplace=True)
                    print(ttdf, file=fp)
                print('', file=fp)
                # TODO - Display credits.

        # Display and/or write plot.
        if plot:
            plot_file_name = '{}.{}'.format(report_file_name, plot_file_name_suffix)
            if self.args.savedir:
                if not os.path.isdir(self.args.savedir):
                    os.mkdir(self.args.savedir, 0o775)
                plot_file_name = os.path.join(self.args.savedir, plot_file_name)
            self.plot(plot_df, plot_file_name)

    def plot(self, pdf, plot_fname):
        """

        :param pdf:
        :type pdf: pd.dataFrame
        :param plot_fname:
        :return:
        """
        num_cols = pdf.shape[1]
        col_select = np.r_[4:num_cols-4]

        # Set credit string base on data source
        data_src = 'usa' if self.args.region != 'country' and self.args.country == 'US' else 'global'
        credit_str = 'Data from the {} extract at {}, Credit: {}'.format(
                     self.data[data_src]['data_date'],
                     self._data_source[data_src]['link'],
                     self._data_source[data_src]['name'])

        # Select label names based on report type and region
        if self.args.region == 'county-state':
            pdf.loc[:, 'County Name'] = pdf.loc[:, 'County Name'] + ', ' + pdf.loc[:, 'State']

        if self.args.region == 'country':
            plot_item_names = list(pdf['Country/Region'])
        else:
            if self.args.country == 'US':
                plot_item_names = list(pdf['State']) if self.args.region == 'state' else list(pdf['County Name'])
            else:
                plot_item_names = list(pdf['Province/State'])

        # Prepare matplotlib figure.
        fig = plt.figure(figsize=(10, 10))
        ax = fig.add_subplot(1, 1, 1)
        ax.set_yscale('log')
        ax.grid(True)
        ax.set_facecolor('#d0dbd5')
        fig.patch.set_facecolor('#eeeeee')
        plt.figtext(0.99, 0.01, '{}\nAnalytics: {}'.format(credit_str, self._analytics_source),
                    horizontalalignment='right', fontsize=8)
        for pname in plot_item_names:
            if self.args.region == 'country':
                y = pdf.loc[pdf['Country/Region'] == pname, :]
                total = pdf.loc[pdf['Country/Region'] == pname, 'Total'].tolist()[0]
            else:
                if self.args.country == 'US':
                    y = pdf.loc[pdf['State'] == pname, :] if self.args.region == 'state' else \
                        pdf.loc[pdf['County Name'] == pname, :]
                    total = pdf.loc[pdf['State'] == pname, 'Total'].tolist()[0] if self.args.region == 'state' \
                            else pdf.loc[pdf['County Name'] == pname, 'Total'].tolist()[0]
                else:
                    y = pdf.loc[pdf['Province/State'] == pname, :]
                    total = pdf.loc[pdf['Province/State'] == pname, 'Total'].tolist()[0]
            y = list(y.iloc[0, col_select])
            lname = '{} ({})'.format(pname, total)
            ax.plot(y, label=lname)
            ax.text(x=len(y), y=y[-1], s=pname,
                    bbox=dict(boxstyle='round,pad=0.2', facecolor='#dddddd'), fontsize=6)
        ax.legend(loc="upper left")
        if self.args.type == 'confirmed':
            if self.args.region == 'country':
                ax.set_title('COVID-19 Confirmed Cases by Country', fontsize=20)
            elif self.args.region == 'state' or self.args.region == 'province':
                ps = 'State' if self.args.country == 'US' else 'Province/State'
                ax.set_title('COVID-19 Confirmed Cases by {} for {}'.format(ps, self.args.country), fontsize=20)
            elif self.args.region == 'county-state':
                ax.set_title('COVID-19 Confirmed Cases by {} {}'.format('US', self.args.region), fontsize=20)
            else:
                state_name = ussa.abbrev_us_state[self.args.state]
                ax.set_title('COVID-19 Confirmed Cases by County for {}'.format(state_name), fontsize=20)
            plt.ylabel('Confirmed Cases', fontsize=16)
        else:
            ax.set_title('COVID-19 Deaths by {}'.format(self.args.region), fontsize=20)
            plt.ylabel('Deaths', fontsize=16)
        plt.xlabel('Days Since Outbreak', fontsize=16)
        if self.args.saveplot:
            plt.savefig(plot_fname, quality=95, optimize=True)
        if self.args.showplot:
            plt.show()


def main():
    """
    Main flow for covid19-vi.
    :return: None
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--about', help='README',
                        action='store_true', default=False)
    parser.add_argument('--length', help='length of sorted reports',
                        type=int, default=10)
    parser.add_argument('--country', help='Name of country for state/province report.',
                        type=str, default='US')
    parser.add_argument('--state', help='Name of state for county report.',
                        type=str, default='NY')
    parser.add_argument('--region', help='country, state, province, count, county-state',
                        type=str, default='country')
    parser.add_argument('--type', help='confirmed, deaths',
                        type=str, default='confirmed')
    parser.add_argument('--download', help='download csv file',
                        action='store_true', default=False)
    parser.add_argument('--saveplot', help='save plot output to a file',
                        action='store_true', default=False)
    parser.add_argument('--showplot', help='plot output',
                        action='store_true', default=False)
    parser.add_argument('--savetable', help='write table to file',
                        action='store_true', default=False)
    parser.add_argument('--showtable', help='display table',
                        action='store_true', default=False)
    parser.add_argument('--savedir', help='destination for saving output',
                        type=str, default=None)
    parser.add_argument('-d', '--debug', help='Debug output',
                        action='store_true', default=False)
    args = parser.parse_args()

    # About me
    if args.about:
        print(__doc__)
        print('Author: ', __author__)
        print('Copyright: ', __copyright__)
        print('Credits: ', __credits__)
        print('License: ', __license__)
        print('Version: ', __version__)
        print('Maintainer: ', __maintainer__)
        print('Status: ', __status__)
        sys.exit(0)

    plot = True if args.showplot or args.saveplot else False

    covid_data = CovidData(args=args, download=args.download)

    covid_data.top_ten(plot=plot)

    sys.exit(0)


if __name__ == '__main__':
    main()
