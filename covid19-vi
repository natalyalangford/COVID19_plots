#!/usr/bin/env python3
""" covid19-vi  -  Visualization utilities for the COVID-19 data from Johns Hopkins.

    Copyright (C) 2020  Natalya Langford

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
__author__ = 'Natalya Langford'
__copyright__ = 'Copyright (C) 2020 Natalya Langford'
__credits__ = ['Ricks-Lab - Collaborator']
__license__ = 'GNU General Public License'
__program_name__ = 'covid19-vi'
__version__ = 'v0.0.1'
__maintainer__ = 'Natalya Langford'
__status__ = 'Under Development'
__docformat__ = 'reStructuredText'
# pylint: disable=multiple-statements
# pylint: disable=line-too-long

import argparse
import sys
import os
from datetime import datetime
import shutil
import pickle
import urllib.request
import us_state_abbrev as ussa
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


DEBUG = False


class CovidData:
    _covid_data = {'global': {'confirmed': 'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv',
                              'deaths': 'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv'},
                   'usa': {'confirmed': 'https://static.usafacts.org/public/data/covid-19/covid_confirmed_usafacts.csv',
                           'deaths': 'https://static.usafacts.org/public/data/covid-19/covid_deaths_usafacts.csv'}}
    _pickle_filename = 'covid_data.pickle'
    _prov_state_countries = ['China', 'Canada', 'Australia', 'France', 'United Kingdom', 'Netherlands', 'Denmark']
    _data_source = 'https://github.com/CSSEGISandData/COVID-19'
    _analytics_source = 'https://github.com/natalyalangford/COVID19_plots'

    def __init__(self, download=False):
        """
        Initialize a CovidData object and populate from interweb if download is True.
        :param download:
        :type download: Bool
        :return None
        """
        self.data = {'global': {'data_date': None,
                                'download_date': None,
                                'confirmed': None,
                                'deaths': None,
                                'recoveries': None},
                     'usa': {'data_date': None,
                             'download_date': None,
                             'confirmed': None,
                             'deaths': None,
                             'recoveries': None}}
        self.read_datafile(download=download)

    def print_sources(self):
        """
        :return: None
        """
        for k, v in self._covid_data.items():
            print(k)
            [print(' {}: {}'.format(k2, v2)) for k2, v2 in v.items()]

    def read_datafile(self, download=False):
        """
        Read covid-19 data from the repository datafiles or a pickle file depends on value of download.
        Source: https://github.com/Ricks-Lab/amdgpu-utils/blob/c10dba61f11b9e5fb44d24acd1fa74122668afc2/GPUmodules/PCImodule.py

        :param download: Download from the interweb if True, else read pickled data.
        :type download: bool
        :return: bool
        """
        global DEBUG
        if not download and os.path.isfile(self._pickle_filename):
            # Read pickle file.
            with open(self._pickle_filename, 'rb') as f:
                self.data = pickle.load(f)
            return True

        for zone, zone_dict in self._covid_data.items():
            if zone == 'usa':
                pass
            for report_key, link in zone_dict.items():
                if DEBUG:
                    temp_file_name = 'covid_{}_{}_{}.csv'.format(zone, report_key, 'test')
                else:
                    temp_file_name = 'covid_{}_{}_{}.csv'.format(zone, report_key, datetime.utcnow().strftime('%m%d_%H%M%S'))
                if not DEBUG or not os.path.isfile(temp_file_name):
                    with urllib.request.urlopen(link) as response, open(temp_file_name, 'wb') as out_file:
                        shutil.copyfileobj(response, out_file)
                self.data[zone][report_key] = self.read_csv_file(temp_file_name, zone)
                if not DEBUG:
                    os.remove(temp_file_name)
                self.data[zone]['data_date'] = self.data[zone][report_key].columns[-5]
            self.data[zone]['download_date'] = datetime.utcnow()

        # Save pickle file.
        with open(self._pickle_filename, 'wb') as f:
            pickle.dump(self.data, f)

        return True

    @staticmethod
    def aggregate_world(df):
        ac_df = df.loc[df['Province/State'].isnull()].copy()
        ac_df.iloc[:, 5:] = ac_df.iloc[:, 5:].fillna(0)
        world_df = ac_df.head(1).copy()
        world_df.iloc[:, 5:] = ac_df.values[:, 5:].sum(axis=0)
        world_df.loc[:, 'Country/Region'] = 'Global'
        world_df.loc[:, 'Province/State'] = np.NaN
        world_df.loc[:, 'Lat'] = 0.0
        world_df.loc[:, 'Long'] = 0.0
        fdf = pd.concat([df, world_df], ignore_index=True)
        return fdf

    @staticmethod
    def aggregate_state_prov(df, country):
        if country == 'US':
            fdf = df.copy()
            state_list = df['State'].unique()
            for state in state_list:
                sc_df = df.loc[df['State'] == state, :].copy()
                state_df = sc_df.head(1).copy()
                sc_df.iloc[:, 5:] = sc_df.iloc[:, 5:].fillna(0)
                state_df.loc[:, 4:] = sc_df.values[:, 4:].sum(axis=0)
                state_df.loc[:, 'County Name'] = np.NaN
                fdf = pd.concat([fdf, state_df], ignore_index=True)
        else:
            sp_df = df.loc[df['Country/Region'] == country, :].copy()
            sp_df.iloc[:, 5:] = sp_df.iloc[:, 5:].fillna(0)
            country_df = sp_df.head(1).copy()
            country_df.loc[:, 5:] = sp_df.values[:, 5:].sum(axis=0)
            country_df.loc[:, 'Province/State'] = np.NaN
            fdf = pd.concat([df, country_df], ignore_index=True)
        return fdf

    def read_csv_file(self, file_name, zone):
        """
        Read and pre-process the csv data files.  Format is from Johns Hopkins GitHub repo.
        :param file_name: File name of the csv file to be processed.
        :return: list
        """
        try:
            df = pd.read_csv(file_name)
        except UnicodeDecodeError:
            df = pd.read_csv(file_name, encoding='ISO-8859-1')

        # TODO - Need regression fit to calculate rate of increase
        if zone == 'global':
            for country in self._prov_state_countries:
                df.loc[(df['Province/State'].isna()) & (df['Country/Region'] == country), 'Province/State'] = country
                df = self.aggregate_state_prov(df, country)
            df = self.aggregate_world(df)
            df.loc[df['Country/Region'] == 'Taiwan*', 'Country/Region'] = 'Taiwan'
        else:
            df = self.aggregate_state_prov(df, 'US')
        df.loc[:, 'Yesterday'] = df.iloc[:, -2]
        df.loc[:, 'Total'] = df.iloc[:, -2]
        df.loc[:, 'DayIncrease'] = df.loc[:, 'Total'] - df.loc[:, 'Yesterday']
        df.loc[:, '%DayIncrease'] = (df.loc[:, 'DayIncrease'] / df.loc[:, 'Yesterday'])
        df.loc[df['%DayIncrease'].isna(), '%DayIncrease'] = 0.0
        df.loc[:, '%DayIncrease'] = round(100.0 * df.loc[:, '%DayIncrease'], 1)
        return df

    def top_ten(self, number=10, report_name='country', report_key='confirmed',
                state='NY', country='US', plot=False):
        """
         Generate tabular data report.
        :param number: Number of lines of data for the table.
        :type number: int
        :param report_name:
        :type report_name: str
        :param report_key:
        :type report_key: str
        :param state:
        :type state: str
        :param country:
        :type country: str
        :param plot:
        :type plot: bool
        :return: None
        """
        # TODO - display age of data.
        print('Top {} Report - {}'.format(report_name, report_key))
        print('  Extract downloaded: {} UTC'.format(self.data['global']['download_date']))
        print('  Data last data point date: {}'.format(self.data['global']['data_date']))
        if report_name == 'country':
            tdf = self.data['global'][report_key].copy()
            tdf = tdf.loc[tdf['Province/State'].isnull()]
            tdf = tdf.sort_values(['Total'], ascending=False).head(number)
            if plot:
                plot_df = tdf.copy()
            tdf = tdf.drop('Province/State', axis=1)
            num_cols = tdf.shape[1]
            col_select = np.r_[0:1, num_cols-9:num_cols]
            ttdf = tdf.iloc[:, col_select].copy()
        elif report_name == 'state' or report_name == 'province':
            if country == 'US':
                ldf = self.data['usa'][report_key]
                ldf = ldf.loc[ldf['County Name'].isnull()].copy()
                ldf = ldf.sort_values(['Total'], ascending=False).head(number)
                if plot:
                    plot_df = ldf.copy()
                num_cols = ldf.shape[1]
                col_select = np.r_[2, num_cols-9:num_cols]
                ttdf = ldf.iloc[:, col_select].copy()
            else:
                ldf = self.data['global'][report_key]
                ldf = ldf.loc[ldf['Country/Region'] == country].copy()
                ldf.loc[(ldf['Province/State'].isna()), 'Province/State'] = 'Total'
                ldf = ldf.sort_values(['Total'], ascending=False).head(number)
                if plot:
                    plot_df = ldf.copy()
                num_cols = ldf.shape[1]
                col_select = np.r_[0:2, num_cols-8:num_cols]
                ttdf = ldf.iloc[:, col_select].copy()
        elif report_name == 'us-county' or report_name == 'county':
            usdf = self.data['usa'][report_key]
            stdf = usdf.loc[usdf['State'] == state].copy()
            stdf.loc[(stdf['County Name'].isna()), 'County Name'] = 'Total'
            stdf = stdf.sort_values(['Total'], ascending=False).head(number)
            if plot:
                plot_df = stdf.copy()
            num_cols = stdf.shape[1]
            col_select = np.r_[1:3, num_cols-9:num_cols]
            ttdf = stdf.iloc[:, col_select].copy()
        else:
            print('Error: Invalid report specified.')
            sys.exit(-1)

        # Display report table.
        with pd.option_context('display.max_rows', None, 'show_dimensions',  False):
            ttdf.reset_index(drop=True, inplace=True)
            print(ttdf)
        print('')
        if plot:
            self.plot(plot_df, report_name, report_key, state, country)

    def plot(self, pdf, report_name, report_key, state, country):
        num_cols = pdf.shape[1]
        col_select = np.r_[4:num_cols-4]
        if report_name == 'country':
            plot_item_names = list(pdf['Country/Region'])
        else:
            if country == 'US':
                plot_item_names = list(pdf['State']) if report_name == 'state' else list(pdf['County Name'])
            else:
                plot_item_names = list(pdf['Province/State'])
        fig = plt.figure(figsize=(10, 10))
        ax = fig.add_subplot(1, 1, 1)
        ax.set_yscale('log')
        ax.grid(True)
        ax.set_facecolor('#d0dbd5')
        fig.patch.set_facecolor('#eeeeee')
        plt.figtext(0.99, 0.01,
                    'Data from the {} Johns Hopkins data on GitHub {}\nAnalytics: {}'.format(
                        self.data['global']['data_date'], self._data_source, self._analytics_source),
                    horizontalalignment='right', fontsize=8)
        for pname in plot_item_names:
            if report_name == 'country':
                y = pdf.loc[pdf['Country/Region'] == pname, :]
                total = pdf.loc[pdf['Country/Region'] == pname, 'Total'].tolist()[0]
            else:
                if country == 'US':
                    y = pdf.loc[pdf['State'] == pname, :] if report_name == 'state' else \
                        pdf.loc[pdf['County Name'] == pname, :]
                    total = pdf.loc[pdf['State'] == pname, 'Total'].tolist()[0] if report_name == 'state' else \
                            pdf.loc[pdf['County Name'] == pname, 'Total'].tolist()[0]
                else:
                    y = pdf.loc[pdf['Province/State'] == pname, :]
                    total = pdf.loc[pdf['Province/State'] == pname, 'Total'].tolist()[0]
            y = list(y.iloc[0, col_select])
            lname = '{} ({})'.format(pname, total)
            ax.plot(y, label=lname)
            ax.text(x=len(y), y=y[-1], s=pname,
                    bbox=dict(boxstyle='round,pad=0.2', facecolor='#dddddd'), fontsize=6)
        ax.legend(loc="upper left")
        if report_key == 'confirmed':
            if report_name == 'country':
                ax.set_title('COVID-19 Confirmed Cases by Country', fontsize=20)
            elif report_name == 'state' or report_name == 'province':
                ps = 'State' if country == 'US' else 'Province/State'
                ax.set_title('COVID-19 Confirmed Cases by {} for {}'.format(ps, country), fontsize=20)
            else:
                state_name = ussa.abbrev_us_state[state]
                ax.set_title('COVID-19 Confirmed Cases by County for {}'.format(state_name), fontsize=20)
            plt.ylabel('Confirmed Cases', fontsize=16)
        else:
            ax.set_title('COVID-19 Deaths by {}'.format(report_name), fontsize=20)
            plt.ylabel('Deaths', fontsize=16)
        plt.xlabel('Days Since Outbreak', fontsize=16)
        plt.show()


def main():
    """
    Main flow for covid19-vi.
    :return: None
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--about', help='README',
                        action='store_true', default=False)
    parser.add_argument('--length', help='length of sorted reports',
                        type=int, default=10)
    parser.add_argument('--country', help='Name of country for state/province report.',
                        type=str, default='US')
    parser.add_argument('--state', help='Name of state for county report.',
                        type=str, default='NY')
    parser.add_argument('--report', help='country, state, province, us-county',
                        type=str, default='confirmed')
    parser.add_argument('--parameter', help='confirmed, deaths',
                        type=str, default='confirmed')
    parser.add_argument('--download', help='download csv file',
                        action='store_true', default=False)
    parser.add_argument('--filename', help='csv file name',
                        type=str, default='')
    parser.add_argument('--table', help='Output table of basic GPU details',
                        action='store_true', default=False)
    parser.add_argument('--plot', help='plot output',
                        action='store_true', default=False)
    parser.add_argument('-d', '--debug', help='Debug output',
                        action='store_true', default=False)
    args = parser.parse_args()

    # About me
    if args.about:
        print(__doc__)
        print('Author: ', __author__)
        print('Copyright: ', __copyright__)
        print('Credits: ', __credits__)
        print('License: ', __license__)
        print('Version: ', __version__)
        print('Maintainer: ', __maintainer__)
        print('Status: ', __status__)
        sys.exit(0)

    global DEBUG
    DEBUG = True if args.debug else False

    if args.parameter not in CovidData._covid_data['global'].keys():
        print('Error: invalid argument for parameters: {}'.format(args.parameter))
        sys.exit(-1)

    covid_data = CovidData(download=args.download)

    covid_data.top_ten(number=args.length, report_name=args.report, report_key=args.parameter,
                       state=args.state, country=args.country, plot=args.plot)

    sys.exit(0)


if __name__ == '__main__':
    main()
